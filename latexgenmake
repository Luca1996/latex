#!/usr/bin/perl -w

# TODO: make it possible to get image physical sizes automatically using LaTeX output, and then use that when converting with DPI

use File::Temp;
use POSIX qw/ceil/;

$DPI_DEFAULT = 300;

# TODO: add error handling (via return values) to these conversion functions
# TODO: make these functions safe with spaces in the args
# TODO: add more conversion rules, like png -> jpg and pdf -> png/jpg
# TODO: possibly, make these into makefile rules

sub imagemagick {
	%params = @_;
	"convert "
		. ((defined($params{'width'}) && defined($params{'height'})) ? "-resize $params{'width'}x$params{'height'} " : "")
		. "-density $dpi "
		. "$params{'in'} $params{'out'}";
};

sub copy {
	%params = @_;
	"cp -r --dereference $params{'in'} $params{'out'}";
};
	

%convert = (
	svg => {
		pdf => sub {
			%params = @_;
			"inkscape "
				. ((defined($params{'width'}) && defined($params{'height'})) ? "--export-width=$params{'width'} --export-height=$params{'height'} " : "--export-dpi=$dpi ")
				. "--export-pdf=$params{'out'} $params{'in'} >/dev/null";
		},
		
		png => sub {
			%params = @_;
			"inkscape "
				. ((defined($params{'width'}) && defined($params{'height'})) ? "--export-width=$params{'width'} --export-height=$params{'height'} " : "--export-dpi=$dpi ")
				. "--export-png=$params{'out'} $params{'in'} >/dev/null";
		},

		jpg => sub {
			%params = @_;
			"inkscape "
				. ((defined($params{'width'}) && defined($params{'height'})) ? "--export-width=$params{'width'} --export-height=$params{'height'} " : "--export-dpi=$dpi ")
				. "--export-png=$params{'out'}.tmp.png $params{'in'} >/dev/null\n"
				. "convert $params{'out'}.tmp.png $params{'out'} >/dev/null\n"
				. "rm $params{'out'}.tmp.png >/dev/null";
		},
	},
	
	pdf => {
		pdf => \&copy,
		png => \&imagemagick,
		jpg => \&imagemagick,
	},
	
	png => {
		png => \&imagemagick,
		jpg => \&imagemagick,
	},
	
	jpg => {
		jpg => \&imagemagick,
	},
	
	tif => {
		png => \&imagemagick,
		jpg => \&imagemagick,
	},
);

# Takes a reference to the convert subroutine and the arguments, calls the sub with the args, and runs each line through system()
sub run_convert_commands {
	($convert_sub, @convert_args) = @_;
	@commands = split "\n", &$convert_sub(@convert_args);
	foreach $command (@commands) {
		system($command);
	}
}

# Takes a reference to the convert subroutine and the arguments, calls the sub with the args, and returns the command string (indented for use with Make)
sub get_convert_commands {
	($convert_sub, @convert_args) = @_;
	$commands = &$convert_sub(@convert_args);
	$commands =~ s/^/\t/gm;
	return $commands;
}

# Used to pick a source file from different files of the same basename
%quality = (
	svg => 1.0,
	pdf => 0.9,
	png => 0.5,
	jpg => 0.1,
	mk => -1.0, # Ignore mk files, since they are generated by this script
);

# Used to choose among the LaTeX-supported formats by applying a weight to each filesize (smaller means higher-priority)
# Note that adding a format here signifies that LaTeX can use it.
%quality_size_factor = (
	pdf => 0.5,
	png => 0.9,
	jpg => 1.0,
);
	
die "Usage: $0 [-n | --no-convert] [--dpi=DPI] [--max-quality] [--latex-figs-file=FILE] FILE_BASENAME OUTPUT_DIR\n" if @ARGV < 2 or grep(/^(-h|--help)$/, @ARGV);
$command_line = join ' ', ($0, @ARGV);

# Parse file args
($basename, $output_dir) = grep(!/^-/, @ARGV);
if (-e $basename) {
	print <<EOF;
# Autogenerated make file, created by $command_line
# No need for any extra commands, since $basename already exists
EOF
	exit;
}

# Parse options
$no_convert = grep(/^(-n|--no-convert)$/, @ARGV);

($dpi) = grep(/^--dpi=/, @ARGV);
if ($dpi) {
	($dpi) = ($dpi =~ /^--dpi=(.*)$/);
} else {
	$dpi = $DPI_DEFAULT;
}
$max_quality = grep (/^--max-quality$/, @ARGV);

($log_figs) = grep(/^--latex-figs-file=/, @ARGV);
if (defined $log_figs) {
	($log_figs) = ($log_figs =~ m/^--latex-figs-file=(.*)$/);
}

# Find the source file associated with the basename
@matches = <$basename.*>;

$source_quality = -1;
for $file_name (@matches) {
	($file_extension) = ($file_name =~ /\.([^\.]*?)$/);
	$file_quality = $quality{$file_extension} || 0.0;
	
	if ($file_quality > $source_quality) {
		$source_quality = $file_quality;
		$source_name = $file_name;
		$source_extension = $file_extension;
	}
}
die "No acceptable source files related to $basename found!\n" if $source_quality < 0;

# Convert to the LaTeX-supported formats
# TODO: Optimize the conversion by avoiding repetitive Inkscape PNG exports
unless ($no_convert) {
	# Find the dimensions of the appropriate image in the figs file
	if (defined($log_figs)) {
		open LOG_FIGS, $log_figs;
		while (<LOG_FIGS>) {
			next if /^#/ || m/^\s*$/; # skip comments and blank lines
			($fig_name, $fig_width, $fig_height) = split /\s*,\s*/;
			if ($fig_name =~ m/^$basename/) { # TODO: possible bug if basename is really short
				%fig_dimensions = ('width' => POSIX::ceil($fig_width * $dpi), 'height' => POSIX::ceil($fig_height * $dpi));
				last;
			}
		}
		close LOG_FIGS;
	}
	
	$best_score = undef;
	$best_format = undef;
	foreach $format (keys %quality_size_factor) {
		$can_convert = exists($convert{$source_extension}{$format});
		next if not $can_convert;
	
		if ($max_quality) {
			# Just use the quality size factor (QSF) as the score
			$format_sample_scores{$format} = $quality_size_factor{$format};
		} else {
			# Find the sample file size and weight it by the QSF to find the score
		
			$format_sample_file = File::Temp::tmpnam() . ".$format";
	
			run_convert_commands($convert{$source_extension}{$format}, 'in' => $source_name, 'out' => $format_sample_file, %fig_dimensions);
	
			$format_sample_size = -s $format_sample_file;
			$format_sample_scores{$format} = $format_sample_size * $quality_size_factor{$format};
		
			unlink($format_sample_file);
		}
	
		# Check if this is the best format so far
		if (!defined($best_score) or $format_sample_scores{$format} < $best_score) {
			$best_format = $format;
			$best_score = $format_sample_scores{$format};
		}
	}
}

if (defined($best_format)) {
	$output_name = "$basename.$best_format";
	$convert_command = get_convert_commands($convert{$source_extension}{$best_format}, 'in' => '$<', 'out' => '$@', %fig_dimensions);
} else {
	$output_name = $source_name;
}

# Makefile instructions to require the output file, so it can get copied to the objdir
print <<EOF;
# Autogenerated make file, created by $command_line

$output_dir/$basename: $output_dir/$output_name
EOF

# Makefile instructions to convert the source file into the output file
if (defined($best_format) and !$no_convert) {
	$considered_formats = join "\n", map { "# $_\t$format_sample_scores{$_}" } keys %format_sample_scores;
	
	print <<EOF;

# Convert to $best_format format at $dpi DPI
# Considered formats (lower score is better):
# Fmt	Score
$considered_formats
$output_dir/$output_name: $source_name
$convert_command
EOF
}
